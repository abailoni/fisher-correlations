#**************************************************************
#**************************************************************
#
# Generate spectra with CAMB and take num. derivatives:
#
#**************************************************************
#**************************************************************

cdef:
    interpolation_tools zero_spectrum_tools
    interpolation_tools derivatives_tools[N_vars]
    interpolation_tools *tools
    interpolation_tools zero_spectrum_tools_anorm
    interpolation_tools derivatives_tools_anorm[N_vars]
    interpolation_tools *tools_anorm
    double k_min, k_max


try:
    import camb
    from camb import model
    check_CAMB = True
except ImportError:
    print "ATTENTION: camb module not found! Spectra can only be imported from file"
    check_CAMB = False
    pass

norms = {}

#Tcmb->2.7255,OmegaNu->0,YHe->.24,MasslessNeutrinos->3.046,MassiveNeutrinos->0,NuMassDegeneracies->{0},NuMassFractions->{1},ScalarInitialCondition->"adiabatic",NonLinear->"none",WantCMB->True,WantTransfer->True,WantCls->True,ScalarSpectralIndex->{.96},ScalarRunning->{0},TensorSpectralIndex->{0},RatioScalarTensorAmplitudes->{1},ScalarPowerAmplitude->{2.1*^-9},PivotScalar->.05,PivotTensor->.05,DoReionization->True,UseOpticalDepth->False,OpticalDepth->0.,ReionizationRedshift->10.,ReionizationFraction->1.,ReionizationDeltaRedshift->.5,TransferHighPrecision->False,WantScalars->True,WantVectors->True,WantTensors->True,WantZstar->True, WantZdrag->True,OutputNormalization->1,MaxEll->1500,MaxEtaK->3000.,MaxEtaKTensor->800.,MaxEllTensor->400,TransferKmax->.9,TransferKperLogInt->0,TransferRedshifts->{0.},AccuratePolarization->True,AccurateReionization->False,AccurateBB->False,DoLensing->True,OnlyTransfers->False,DerivedParameters->True,MassiveNuMethod->"best"

INPUT_PATH = "INPUT/autogenerated_CAMB/"

def Fourier_W_k(x):
    return 3./x**3 * (np.sin(x)-x*np.cos(x))

# Set compute_CAMB=True to force the computation of the data
def compute_CAMB_spectra(compute_CAMB=False,N_points=7000,mink=1e-12,maxk=1.55):
    import_variables = ["spectrum","h","n_s","Om_b","Om_c"]
    ref_values_array = np.array([ref_values[var] for var in import_variables[1:]])
    CAMB_spectra, CAMB_s8 = {}, {} # s8 no longer necessary..
    h, omb, omc, ns = ref_values["h"], ref_values["Om_b"], ref_values["Om_c"], ref_values["n_s"] # just for convenience

    # -------------------------------------
    # Check if data were already computed:
    # -------------------------------------
    for (dirpath, dirnames, filenames) in walk(INPUT_PATH):
        names = [ fi for fi in filenames if fi.endswith(".csv") ]
        break
    if "params.csv" in names:
        saved_data = np.genfromtxt(INPUT_PATH+"params.csv", delimiter=' ',dtype='str')
        # np.loadtxt(open(INPUT_PATH+"params.csv","rb"))
        old_values = {}
        for i in range(saved_data.shape[0]):
            var = saved_data[i,0]
            old_values[var] = float(saved_data[i,1])
        for var in old_values:
            if abs(old_values[var]-ref_values[var])>1e-2: #different
                compute_CAMB = True
    else:
        compute_CAMB = True
    if compute_CAMB:
        # ----------------------------
        # Generate spectra with CAMB:
        # ----------------------------
        if check_CAMB==False:
            print "###### External files not found. Process terminated #######"
            return -1
        print('\nUsing CAMB installed at '+ os.path.realpath(os.path.join(os.getcwd(),'..')))
        sys.path.insert(0,os.path.realpath(os.path.join(os.getcwd(),'..')))

        # REFERENCE SPECTRUM:
        pars = camb.CAMBparams()

        # Santiago's values: (in teoria..)
        pars.WantTransfer = 1
        pars.set_for_lmax(lmax=1500, max_eta_k=3000.)
        pars.InitPower.set_params(As=2.1*1e-9, nrun=0, nrunrun=0, r=0, nt=None, ntrun=0, pivot_scalar=0.05, pivot_tensor=0.05, parameterization=2)

        pars.set_cosmology(H0=h*100, ombh2=omb*h**2, omch2=omc*h**2)
        pars.set_dark_energy(w=ref_values["w_0"])
        pars.InitPower.set_params(ns=ns)
        print "\nComputing spectrum and derivatives with CAMB:"
        print " - reference spectrum,"
        pars.set_matter_power(redshifts=[0.], kmax=maxk)
        pars.NonLinear = model.NonLinear_none
        results = camb.get_results(pars)
        kh, z, CAMB_spectra["spectrum"] = results.get_matter_power_spectrum(minkh=mink, maxkh=maxk, npoints = N_points)
        kh = np.array(kh)
        CAMB_spectra["spectrum"] = np.array(CAMB_spectra["spectrum"][0])
        #CAMB_s8["spectrum"] = np.array(results.get_sigma8())
        np.savetxt(INPUT_PATH+"spectrum.csv",np.column_stack((kh,CAMB_spectra["spectrum"])))

        # Hubble parameter:
        print " - h,"
        pars.set_cosmology(H0=h*100*(1+epsilon), ombh2=omb* (h*(1+epsilon))**2, omch2=omc* (h*(1+epsilon))**2)
        results.calc_power_spectra(pars)
        _, _, CAMB_spectra["h"] = results.get_matter_power_spectrum(minkh=mink, maxkh=maxk, npoints = N_points)
        CAMB_spectra["h"] = np.array(CAMB_spectra["h"][0])
        #CAMB_s8["h"] = np.array(results.get_sigma8())
        pars.set_cosmology(H0=h*100, ombh2=omb*h**2, omch2=omc*h**2)
        np.savetxt(INPUT_PATH+"h.csv",np.column_stack((kh,CAMB_spectra["h"])))

        # n_s parameter:
        print " - ns"
        pars.InitPower.set_params(ns=ns*(1+epsilon))
        results.calc_power_spectra(pars)
        _, _, CAMB_spectra["n_s"] = results.get_matter_power_spectrum(minkh=mink, maxkh=maxk, npoints = N_points)
        CAMB_spectra["n_s"] = np.array(CAMB_spectra["n_s"][0])
        #CAMB_s8["n_s"] = np.array(results.get_sigma8())
        pars.InitPower.set_params(ns=ns)
        np.savetxt(INPUT_PATH+"n_s.csv",np.column_stack((kh,CAMB_spectra["n_s"])))

        # Omega_b parameter:
        print " - Omega_b,"
        pars.set_cosmology(ombh2=omb*(1+epsilon)*h**2)
        results.calc_power_spectra(pars)
        _, _, CAMB_spectra["Om_b"] = results.get_matter_power_spectrum(minkh=mink, maxkh=maxk, npoints = N_points)
        CAMB_spectra["Om_b"] = np.array(CAMB_spectra["Om_b"][0])
        #CAMB_s8["Om_b"] = np.array(results.get_sigma8())
        pars.set_cosmology(ombh2=omb*h**2)
        np.savetxt(INPUT_PATH+"Om_b.csv",np.column_stack((kh,CAMB_spectra["Om_b"])))

        # Omega_c parameter:
        print " - Omega_c,"
        pars.set_cosmology(omch2=omc*(1+epsilon)*h**2)
        results.calc_power_spectra(pars)
        _, _, CAMB_spectra["Om_c"] = results.get_matter_power_spectrum(minkh=mink, maxkh=maxk, npoints = N_points)
        CAMB_spectra["Om_c"] = np.array(CAMB_spectra["Om_c"][0])
        #CAMB_s8["Om_c"] = np.array(results.get_sigma8())
        pars.set_cosmology(omch2=omc*h**2)
        np.savetxt(INPUT_PATH+"Om_c.csv",np.column_stack((kh,CAMB_spectra["Om_c"])))


        np.savetxt(INPUT_PATH+"params.csv",np.column_stack((np.array(import_variables[1:]),ref_values_array)),delimiter=" ", fmt="%s")
    else:
        # ----------------------------------
        # Import previously computed data:
        # ----------------------------------
        print "\nCAMB spectra already computed previously. Importing files..."
        for var in import_variables:
            saved_data = np.loadtxt(open(INPUT_PATH+var+".csv","rb"))
            CAMB_spectra[var] = saved_data[:,1]
            CAMB_spectra[var] = CAMB_spectra[var].copy(order="C")
            if var=="spectrum":
                kh = saved_data[:,0]
                kh = kh.copy(order="C")
        print "--> Done!"


    # ------------------------------------
    # Interpolate with GSL and normalise:
    # ------------------------------------
    print "\nInterpolating with GSL and computing sigma8. . ."
    global norms, zero_spectrum_tools_anorm, zero_spectrum_tools, derivatives_tools_anorm, derivatives_tools, tools_anorm, tools
    for var in import_variables:
        if var=="spectrum":
            tools_anorm = &zero_spectrum_tools_anorm
            tools = &zero_spectrum_tools
        else: # numvar goes from 1 to 4
            tools_anorm = &derivatives_tools_anorm[n_var_import[var]]
            tools = &derivatives_tools[n_var_import[var]]
        alloc_interp_GSL(np.log(kh), np.log(CAMB_spectra[var]), tools_anorm)
        # Normalise and interpolate:
        norms[var] = 2*np.pi**2 / quad( lambda lnk, var=var: np.exp(3*lnk) * np.exp(eval_interp_GSL(lnk, tools_anorm)) * Fourier_W_k(np.exp(lnk)*R_sigma)**2 , np.log(kminref), np.log(kmaxref), epsrel=sigma8precision, full_output=1)[0]
        alloc_interp_GSL(np.log(kh), np.log(CAMB_spectra[var] * ref_values['sigma8']**2 *norms[var] ), tools)
    print "--> Done!"

    # Set k_min and k_max:
    global k_min, k_max
    k_min, k_max = mink, maxk
    return

def print_s8(var):
    print norms[var]

#----------------------------------------------
# Wrappers zero_spectrum and CLASS derivatives:
#----------------------------------------------

# ZERO SPECTRUM:
cdef double zero_spectrum(double k):
    return exp(eval_interp_GSL(log(k), &zero_spectrum_tools))

def zero_spectrum_py(k):
    return zero_spectrum(k)
#def zero_spectrum_FFT_3D(mod_k):
#    cdef int shape = mod_k.shape[0]
#    results = np.empty((shape,shape,shape))
#    cdef:
#        double[:,:,::1] mod_k_c = mod_k
#        double[:,:,::1] results_c = results
#    # Can be optimised because it's symmetric:
#    cdef double mod_k_val
#    for i in range(shape):
#        for j in range(shape):
#            for t in range(shape):
#                mod_k_val = mod_k_c[i,j,t]
#                if mod_k_val>k_max or mod_k_val<k_min:
#                    results_c[i,j,t] = 0. #Really bad, put an asympthotic behav. please
#                else:
#                    results_c[i,j,t] = zero_spectrum(mod_k_val)
#    return results


# TEMP: ---------------------------------------
# Import and interpolate cosmomathica derivative:
cdef interpolation_tools derK_tools
def import_zero_spectrum_der_k():
    global derK_tools
    print "Importing Cosmomathica derivative..."
    data = np.loadtxt(open("INPUT/Santi/CAMB_derK_0.csv","rb"),delimiter="\t")
    ln_ks, der_lnP = data[:,0].copy(order="C"), data[:,1].copy(order="C")
    alloc_interp_GSL(ln_ks, der_lnP, &derK_tools)

cdef double zero_spectrum_der_k(double k):
    return eval_interp_GSL(log(k), &derK_tools)

# ---------------------------------------------

#cdef double zero_spectrum_der_k(double k):
#    return zero_spectrum(k)/k * gsl_spline_eval_deriv(zero_spectrum_tools[0].spline, log(k), zero_spectrum_tools[0].acc)

def zero_spectrum_der_k_py(k):
    return zero_spectrum_der_k(k)


cdef double CAMB_numerical_paramDER(double k, int num_var): # Var goes from 1 to 4
    return (exp(eval_interp_GSL(log(k), &derivatives_tools[num_var])) - zero_spectrum(k)) / (ref_val_v[num_var])
def CAMB_numerical_paramDER_py(k,num_var):
    return CLASS_der(k,num_var)
